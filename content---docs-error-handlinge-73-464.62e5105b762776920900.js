(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{45:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",function(){return s}),t.d(n,"rightToc",function(){return i}),t.d(n,"default",function(){return l});t(0);var r=t(59);function a(){return(a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e}).apply(this,arguments)}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s={id:"error-handling",title:"Error Handling"},i=[{value:"The four ways a channel can error",id:"the-four-ways-a-channel-can-error",children:[{value:"1. Calling stop with an error",id:"1-calling-stop-with-an-error",children:[]},{value:"2. Calling the throw method",id:"2-calling-the-throw-method",children:[]},{value:"3. The executor throws an error",id:"3-the-executor-throws-an-error",children:[]},{value:"4. A promise passed to the push function rejects",id:"4-a-promise-passed-to-the-push-function-rejects",children:[]}]}],h={rightToc:i},c="wrapper";function l(e){var n=e.components,t=o(e,["components"]);return Object(r.b)(c,a({},h,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Because error handling is important for creating robust applications, channels are designed to catch and propagate any errors they receive in a predictable fashion. Every promise which is passed to a channel is preemptively caught using ",Object(r.b)("inlineCode",{parentName:"p"},"Promise.prototype.catch")," to prevent unhandled rejections, and the errors are forwarded to the iterator methods ",Object(r.b)("inlineCode",{parentName:"p"},"next"),"/",Object(r.b)("inlineCode",{parentName:"p"},"return"),"/",Object(r.b)("inlineCode",{parentName:"p"},"throw")," so channel consumers can handle them."),Object(r.b)("h2",null,Object(r.b)("a",a({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"the-four-ways-a-channel-can-error"})),Object(r.b)("a",a({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#the-four-ways-a-channel-can-error"}),"#"),"The four ways a channel can error"),Object(r.b)("h3",null,Object(r.b)("a",a({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"1-calling-stop-with-an-error"})),Object(r.b)("a",a({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#1-calling-stop-with-an-error"}),"#"),"1. Calling ",Object(r.b)("inlineCode",{parentName:"h3"},"stop")," with an error"),Object(r.b)("p",null,"The most common way to cause a channel to error is to pass an argument to the ",Object(r.b)("inlineCode",{parentName:"p"},"stop")," function:"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),'const chan = new Channel((push, stop) => {\n  for (let i = 0; i < 100; i++) {\n    push(i);\n  }\n  stop(new Error("Stop in the name of love üòò"));\n});\n\n(async () => {\n  try {\n    console.log(await chan.next()); // { value: 0, done: true }\n    console.log(await chan.next()); // { value: 1, done: true }\n    console.log(await chan.next()); // { value: 2, done: true }\n    // This line throws an error.\n    console.log(await errorChan().return());\n  } catch (err) {\n    console.log(err); // Error: Stop in the name of love üòò\n  } finally {\n    console.log(await chan.next()); // { done: true }\n    console.log(await chan.next()); // { done: true }\n  }\n})();\n')),Object(r.b)("p",null,"When ",Object(r.b)("inlineCode",{parentName:"p"},"stop")," is called with an error, values which were previously pushed can continue to be pulled. When there are no more values, the final call to ",Object(r.b)("inlineCode",{parentName:"p"},"next")," rejects with the error. If the channel is ended prematurely with the ",Object(r.b)("inlineCode",{parentName:"p"},"return")," method, the channel drops any remaining values and rejects with the error."),Object(r.b)("p",null,"As you can see in the example above, channels error only once before entering a finished state where all calls to ",Object(r.b)("inlineCode",{parentName:"p"},"next")," resolve to ",Object(r.b)("inlineCode",{parentName:"p"},"{ done: true }"),". This mirrors the behavior of async generator objects. Because channels can only be stopped once, only the first call to ",Object(r.b)("inlineCode",{parentName:"p"},"stop")," has an effect on the channel, and any errors passed in subsequent calls to ",Object(r.b)("inlineCode",{parentName:"p"},"stop")," are dropped."),Object(r.b)("h3",null,Object(r.b)("a",a({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"2-calling-the-throw-method"})),Object(r.b)("a",a({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#2-calling-the-throw-method"}),"#"),"2. Calling the ",Object(r.b)("inlineCode",{parentName:"h3"},"throw")," method"),Object(r.b)("p",null,"The async iterator interface defines an optional ",Object(r.b)("inlineCode",{parentName:"p"},"throw")," method which allows consumers to throw errors into the iterator. With async generators, yield statements can be wrapped in a ",Object(r.b)("inlineCode",{parentName:"p"},"try")," block to catch these errors. Channels implement the throw method, but don‚Äôt have any methods for recovering from errors thrown in."),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),'const chan = Channel((push, stop) => {\n  for (let i = 0; i < 10; i++) {\n    push(i);\n  }\n});\n\n(async () => {\n  try {\n    const next = chan.next();\n    // this line does not throw because there is a pending call to next\n    console.log(await chan.throw("This error is passed to next üìû")); // { done: true } \n    // this line throws the error above\n    console.log(await next);\n  } catch (err) {\n    console.log(err); // Error: This error is passed to next üìû\n  } finally {\n    console.log(await chan.next()); // { done: true }\n  }\n})();\n')),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"throw")," method is equivalent to calling the ",Object(r.b)("inlineCode",{parentName:"p"},"stop")," function and ",Object(r.b)("inlineCode",{parentName:"p"},"return")," method in sequence, so ",Object(r.b)("inlineCode",{parentName:"p"},"throw")," blows away any pending values and finishes the channel. Because ",Object(r.b)("inlineCode",{parentName:"p"},"throw")," rethrows errors if there are no pending calls to ",Object(r.b)("inlineCode",{parentName:"p"},"next"),", this method is of limited utility and mainly provided for compatability purposes."),Object(r.b)("h3",null,Object(r.b)("a",a({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"3-the-executor-throws-an-error"})),Object(r.b)("a",a({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#3-the-executor-throws-an-error"}),"#"),"3. The executor throws an error"),Object(r.b)("p",null,"The channel constructor catches both synchronous and asynchronous errors thrown by the executor."),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),'const chan = new Channel((push, stop) => {\n  push("a");\n  push("b");\n  push("c");\n  // this error is dropped\n  stop(new Error("My error"));\n  // this error takes priority\n  throw new Error("This executor is busted ‚ò†Ô∏è");\n});\n\n(async () => {\n  try {\n    for await (const letter of chan) {\n      console.log(letter); // "a", "b", "c"\n    }\n  } catch (err) {\n    console.log(err); // Error: This executor is busted ‚ò†Ô∏è\n  } finally {\n    console.log(await chan.next()); // { done: true }\n  }\n})();\n')),Object(r.b)("p",null,"When an error occurs in the executor, the channel is automatically stopped. Because errors which occur in the executor are usually indicative of a programming mistake, the error thrown by the executor takes precedence over errors passed via ",Object(r.b)("inlineCode",{parentName:"p"},"stop")," or ",Object(r.b)("inlineCode",{parentName:"p"},"throw"),", regardless of when they were passed to the channel."),Object(r.b)("h3",null,Object(r.b)("a",a({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"4-a-promise-passed-to-the-push-function-rejects"})),Object(r.b)("a",a({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#4-a-promise-passed-to-the-push-function-rejects"}),"#"),"4. A promise passed to the ",Object(r.b)("inlineCode",{parentName:"h3"},"push")," function rejects"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),'const chan = new Channel(async (push, stop) => {\n  await push("a");\n  await push("b");\n  await push("c");\n  await push(new Promise((_, reject) => {\n    setTimeout(() => {\n      reject(new Error("A rejection passed to push ‚è∞"));\n    }, 100);\n  }));\n  // these values are ignored\n  await push("e");\n  await push("f");\n  // these errors are ignored\n  stop(new Error("My error"));\n  throw new Error("this executor is busted");\n});\n\n(async () => {\n  try {\n    for await (const letter of chan) {\n      console.log(letter); // "a", "b", "c"\n    }\n  } catch (err) {\n    console.log(err); // Error: A rejection passed to push ‚è∞\n  } finally {\n    console.log(await chan.next()); // { done: true }\n  }\n})();\n')),Object(r.b)("p",null,"Channels unwrap promises and promise-like objects which are passed to ",Object(r.b)("inlineCode",{parentName:"p"},"push"),". If a promise passed to ",Object(r.b)("inlineCode",{parentName:"p"},"push")," rejects, the channel finishes and any further pending values are dropped. The pushed rejection is like a time-bomb which blows up the channel and prevents any more values from being pulled, regardless of when those values settled. A rejection which resolves before the channel is stopped takes precedence over all other errors passed to channels. However, if a pushed rejection settles ",Object(r.b)("em",{parentName:"p"},"after")," the channel has already stopped, the rejection is dropped and the channel yields ",Object(r.b)("inlineCode",{parentName:"p"},"{ done: true }")," instead. This behavior is useful when creating ",Object(r.b)("a",a({parentName:"p"},{href:"inverted-channels"}),"inverted channels"),"."))}l.isMDXComponent=!0}}]);