(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{43:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",function(){return s}),t.d(n,"rightToc",function(){return i}),t.d(n,"default",function(){return b});t(0);var a=t(59);function r(){return(r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s={id:"rationale",title:"Rationale"},i=[{value:"Why not async generators?",id:"why-not-async-generators",children:[]},{value:"Why not observables?",id:"why-not-observables",children:[]}],c={rightToc:i},l="wrapper";function b(e){var n=e.components,t=o(e,["components"]);return Object(a.b)(l,r({},c,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("p",null,"While ",Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/tc39/proposal-async-iteration"}),"async iterators")," are available in most modern javascript runtimes, they have yet to achieve widespread usage due to various perceived ",Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/apollographql/graphql-subscriptions/issues/116"}),"flaws")," and ",Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/tc39/proposal-async-iteration/issues/126"}),"pitfalls"),". What’s needed is something like the ",Object(a.b)("inlineCode",{parentName:"p"},"Promise")," constructor, which helped promises succeed by providing a common pattern for converting callback-based APIs into promises. The ",Object(a.b)("inlineCode",{parentName:"p"},"Channel")," constructor makes it easy to turn ",Object(a.b)("em",{parentName:"p"},"any")," callback-based source of data into an async iterator, and prevents common async iterator mistakes ",Object(a.b)("a",r({parentName:"p"},{href:"safety"}),"by design"),". The constructor pattern is easy to memorize and adaptable for almost every async iterator use case."),Object(a.b)("h2",null,Object(a.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"why-not-async-generators"})),Object(a.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#why-not-async-generators"}),"#"),"Why not async generators?"),Object(a.b)("p",null,"Channels are meant to be used alongside async generators rather than replace them. The problem with using async generators exclusively is that they rely on the ",Object(a.b)("inlineCode",{parentName:"p"},"yield"),", ",Object(a.b)("inlineCode",{parentName:"p"},"return")," and ",Object(a.b)("inlineCode",{parentName:"p"},"throw")," statements to produce values, which are unavailable in child closures. "),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"async function* messages(url) {\n  const socket = new WebSocket(url);\n  socket.onmessage = (ev) => {\n     // can’t make the outer generator yield from here.\n  };\n}\n")),Object(a.b)("p",null,"The solution using async generators is often some ad-hoc ",Object(a.b)("inlineCode",{parentName:"p"},"while (true)")," loop which awaits a promise which adds and removes event handlers for each iteration. The resulting code is often prone to race-conditions, dropped messages, and memory leaks unless done with an expert understanding of generators and promises. Channels behave identically to async generators, except they provide the ",Object(a.b)("inlineCode",{parentName:"p"},"yield"),", ",Object(a.b)("inlineCode",{parentName:"p"},"return")," and ",Object(a.b)("inlineCode",{parentName:"p"},"throw")," statements as the functions ",Object(a.b)("inlineCode",{parentName:"p"},"push")," and ",Object(a.b)("inlineCode",{parentName:"p"},"stop"),". These functions give imperative control over channels in child closures, making channels ideal for use with callbacks."),Object(a.b)("p",null,"Once you have converted callback-based APIs to channel-returning functions, channels can be used seamlessly with async generators to write rich, easy-to-understand async code."),Object(a.b)("h2",null,Object(a.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"why-not-observables"})),Object(a.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#why-not-observables"}),"#"),"Why not observables?"),Object(a.b)("p",null,"Observables are often thought of as competing with async iterators and therefore channels, and it’s true that most channel code can be rewritten with observables. Here, for instance, is the ",Object(a.b)("a",r({parentName:"p"},{href:"quickstart#listening-for-the-konami-code"}),"Konami code example"),", rewritten using ",Object(a.b)("inlineCode",{parentName:"p"},"rxjs"),":"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),'import { Observable } from "rxjs";\nimport { takeWhile } from "rxjs/operators";\nconst keys = new Observable(subscriber => {\n  const listener = ev => {\n    if (ev.key === "Escape") {\n      subscriber.complete();\n    } else {\n      subscriber.next(ev.key);\n    }\n  };\n  window.addEventListener("keyup", listener);\n  return () => window.removeEventListener("keyup", listener);\n});\n\nconst konami = ["ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowLeft", "ArrowRight", "ArrowLeft", "ArrowRight", "b", "a"];\n\nlet i = 0;\nlet subscription = keys\n  .pipe(\n    rxjs.operators.takeWhile(key => {\n      if (key === konami[i]) {\n        i++;\n      } else {\n        i = 0;\n      }\n      if (i >= konami.length) {\n        console.log("KONAMI!!!");\n        return false;\n      }\n      return true;\n    }),\n  )\n  .subscribe();\n')),Object(a.b)("p",null,"While you can often create an equivalent observable for any channel, there are several differences that make channels much nicer to use. Firstly, channels support ",Object(a.b)("inlineCode",{parentName:"p"},"async/await")," and ",Object(a.b)("inlineCode",{parentName:"p"},"for await…of")," syntax, so we don’t need a library of “operators” like ",Object(a.b)("inlineCode",{parentName:"p"},"takeWhile")," to consume channels. Rather than using ",Object(a.b)("inlineCode",{parentName:"p"},"map")," operator, we can assign a variable, rather than using the ",Object(a.b)("inlineCode",{parentName:"p"},"filter")," operator, we can use an ",Object(a.b)("inlineCode",{parentName:"p"},"if")," statement, and rather than using the ",Object(a.b)("inlineCode",{parentName:"p"},"takeWhile")," or ",Object(a.b)("inlineCode",{parentName:"p"},"takeUntil")," operators, we can use a ",Object(a.b)("inlineCode",{parentName:"p"},"break")," statement. Using ",Object(a.b)("inlineCode",{parentName:"p"},"for await…of")," loops allows us to leverage what we already know about synchronous loops and control-flow statements to write cleaner, more intuitive code. I suspect that if observables ever ",Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/ReactiveX/rxjs/issues/4002"}),"decided to support the async iterator protocol"),", the market for higher-order observable functions would collapse overnight."),Object(a.b)("p",null,"Secondly, despite all the claims observable advocates make about how observables are “monadic” or that they are the “mathematical dual” of synchronous iterables, observables are ultimately callback-based APIs. This means that it’s difficult to use observables with promises and they suffer from the same issue of “callback hell” which promises were designed to solve. Observable libraries are aware of this and provide “higher-order observable operators” which work on observables of observables, but these solutions are seldom used and virtually incomprehensible to human beings, who don’t normally think in terms of extradimensional spaces."))}b.isMDXComponent=!0}}]);