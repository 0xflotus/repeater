(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{36:function(e,a,t){"use strict";t.r(a),t.d(a,"default",function(){return f});var n=t(0),r=t.n(n),l=t(58),o=t.n(l),c=t(59),s=t(60),i=t.n(s),m=t(61),u=t.n(m),d=t(63),h=t(76),g=t.n(h);function p(e){var a=e.to,t=e.children;return r.a.createElement(c.a,{to:a,className:"button button--outline button--primary button--lg"},t)}function b(){var e=i()().siteConfig,a=void 0===e?{}:e;return r.a.createElement("header",{className:o()("hero",g.a.hero)},r.a.createElement("div",{className:g.a.background,style:{backgroundImage:"url(".concat(u()("img/smpte.svg"),")")}}),r.a.createElement("div",{className:"container"},r.a.createElement("img",{src:u()("img/logo.svg"),alt:"logo"}),r.a.createElement("h1",{className:"hero__title"},a.title),r.a.createElement("p",{className:"hero__subtitle"},a.tagline),r.a.createElement(p,{to:u()("docs/quickstart")},"Get Started")))}function E(e){var a=e.title,t=e.children,n=e.color,l=void 0===n?"white":n;return r.a.createElement("div",{className:"col"},r.a.createElement("h2",{className:"text--center",style:{color:l}},a),r.a.createElement("p",{className:"text--justify"},t))}function v(){return r.a.createElement("main",{className:"container padding-horiz--md margin-vert--xl"},r.a.createElement("div",{className:"row"},r.a.createElement("h1",null,"üë∑‚Äç‚ôÄÔ∏èTHESE DOCS ARE  UNDER CONSTRUCTION üë∑‚Äç‚ôÇÔ∏è")),r.a.createElement("div",{className:"row"},r.a.createElement(E,{title:"Convenient",color:"#00ABAA"},"The Channel class provides a promise-fluent API for creating async iterators. The same constructor can be used to convert event emitters, streams, websockets, web workers, observers, observables or any other callback-based data source into a format which can be read using"," ",r.a.createElement("code",null,"async/await")," and ",r.a.createElement("code",null,"for await‚Ä¶of"),"statements."),r.a.createElement(E,{title:"Safe",color:"#BA00AC"},"Channels prevent common mistakes developers make when rolling async iterators by hand. By initializing lazily, providing strategies for dealing with backpressure, and propagating errors in a predictable fashion, channels ensure that event handlers are cleaned up and help you quickly locate bottlenecks and deadlocks."),r.a.createElement(E,{title:"Powerful",color:"#00B100"},"The Channel constructor is well-specified and flexible enough to model complex patterns like cancelable timers, async semaphores, and generic pubsub classes. The Channel class also provides static combinator methods like ",r.a.createElement("code",null,"Channel.race")," and ",r.a.createElement("code",null,"Channel.merge")," ","which allow you to use async iterators for reactive programming purposes.")))}function f(){return r.a.createElement(d.a,null,r.a.createElement(b,null),r.a.createElement(v,null))}},76:function(e,a,t){e.exports={hero:"hero_znNTAGhW",background:"background_2gyGDhQH"}}}]);