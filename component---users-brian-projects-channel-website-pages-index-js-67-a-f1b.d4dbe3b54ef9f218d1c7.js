(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{35:function(e,t,a){"use strict";a.r(t),a.d(t,"default",function(){return E});var n=a(0),r=a.n(n),o=a(57),l=a.n(o),c=a(58),s=a(59),i=a.n(s),m=a(60),u=a.n(m),d=a(62),h=a(75),g=a.n(h);function p(e){var t=e.to,a=e.children;return r.a.createElement(c.a,{to:t,className:"button button--outline button--primary button--lg"},a)}function b(){var e=i()().siteConfig,t=void 0===e?{}:e;return r.a.createElement("header",{className:l()("hero",g.a.hero)},r.a.createElement("div",{className:g.a.background,style:{backgroundImage:"url(".concat(u()("img/smpte.svg"),")")}}),r.a.createElement("div",{className:"container"},r.a.createElement("img",{src:u()("img/logo.svg"),alt:"logo"}),r.a.createElement("h1",{className:"hero__title"},t.title),r.a.createElement("p",{className:"hero__subtitle"},t.tagline),r.a.createElement(p,{to:u()("docs/quickstart")},"Get Started")))}function f(e){var t=e.title,a=e.children,n=e.color,o=void 0===n?"white":n;return r.a.createElement("div",{className:"col"},r.a.createElement("h2",{className:"text--center",style:{color:o}},t),r.a.createElement("p",{className:"text--justify"},a))}function v(){return r.a.createElement("main",{className:"container padding-horiz--md margin-vert--xl"},r.a.createElement("div",{className:"row"},r.a.createElement(f,{title:"Convenient",color:"#00C4C3"},"The Channel class provides a promise-fluent API for creating async iterators. The same constructor can be used to convert event emitters, streams, websockets, web workers, mutation observers, observables or any other callback-based source of data into objects which can be consumed using ",r.a.createElement("code",null,"async/await")," and ",r.a.createElement("code",null,"for awaitâ€¦of"),"statements."),r.a.createElement(f,{title:"Safe",color:"#D300C5"},"Channels prevent common mistakes that are made when rolling async iterators by hand. By initializing lazily, providing strategies for dealing with backpressure, and propagating errors in a predictable fashion, channels ensure that event handlers are cleaned up and help you quickly identify potential bottlenecks and deadlocks."),r.a.createElement(f,{title:"Powerful",color:"#00CA00"},"The Channel constructor is well-specified and flexible enough to model complex patterns like cancelable timers, async semaphores, and generic pubsub classes. The Channel class also provides static combinator methods like ",r.a.createElement("code",null,"Channel.merge")," which allow you to use async iterators for reactive programming purposes.")))}function E(){return r.a.createElement(d.a,null,r.a.createElement(b,null),r.a.createElement(v,null))}},75:function(e,t,a){e.exports={hero:"hero_znNTAGhW",background:"background_2gyGDhQH"}}}]);