(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{36:function(e,a,t){"use strict";t.r(a),t.d(a,"default",function(){return v});var n=t(0),r=t.n(n),l=t(60),c=t.n(l),o=t(62),s=t.n(o),i=t(63),m=t.n(i),u=t(61),d=t(65),h=t(78),g=t.n(h);function p(){var e=s()().siteConfig,a=void 0===e?{}:e;return r.a.createElement("header",{className:c()("hero",g.a.hero)},r.a.createElement("div",{className:g.a.background,style:{backgroundImage:"url(".concat(m()("img/smpte.svg"),")")}}),r.a.createElement("div",{className:"container"},r.a.createElement("img",{src:m()("img/logo.svg"),alt:"logo"}),r.a.createElement("h1",{className:"hero__title"},a.title),r.a.createElement("p",{className:"hero__subtitle"},a.tagline),r.a.createElement(u.a,{to:m()("docs/quickstart"),className:"button button--outline button--primary button--lg"},"Get Started")))}function b(e){var a=e.title,t=e.children,n=e.color,l=void 0===n?"white":n;return r.a.createElement("div",{className:"col"},r.a.createElement("h2",{className:"text--center",style:{color:l}},a),r.a.createElement("p",{className:"text--justify"},t))}function E(){return r.a.createElement("main",{className:"container padding-horiz--md margin-vert--xl"},r.a.createElement("div",{className:"row"},r.a.createElement(b,{title:"Convenient",color:"#00ABAA"},"The Channel class provides a promise-fluent API for creating async iterators. You can reuse the same constructor to convert event emitters, streams, websockets, or other callback-based data sources into objects which can be read using ",r.a.createElement("code",null,"async/await")," and"," ",r.a.createElement("code",null,"for awaitâ€¦of")," statements."),r.a.createElement(b,{title:"Safe",color:"#BA00AC"},"Channels prevent common mistakes people make when rolling async iterators by hand. By executing lazily, dealing with backpressure, and propagating errors in a predictable manner, channels ensure that event listeners are cleaned up and that bottlenecks and deadlocks are discovered quickly."),r.a.createElement(b,{title:"Powerful",color:"#00B100"},"You can use channels to implement architectural patterns like cancelable timers, semaphores, and generic pubsub classes. The Channel class also provides static methods like ",r.a.createElement("code",null,"Channel.race")," and"," ",r.a.createElement("code",null,"Channel.merge")," which allow you to use async iterators for reactive programming purposes.")))}function v(){return r.a.createElement(d.a,null,r.a.createElement(p,null),r.a.createElement(E,null))}},78:function(e,a,t){e.exports={hero:"hero_znNTAGhW",background:"background_2gyGDhQH"}}}]);